Код предназначен для поиска всех вхождений подстроки T в строке S с использованием двух методов: "грубого" (brute force) и с использованием хеширования.
Функция isMatch
Определение функции
function isMatch(S, T, start) {
Эта функция принимает три аргумента: строку S, подстроку T и начальную позицию start, с которой начинается проверка.
Цикл по символам подстроки
    for (let j = 0; j < T.length; j++) {
Здесь мы начинаем цикл, который проходит по каждому символу подстроки T.
Сравнение символов
        if (S[start + j] !== T[j]) {
            return false; // Если символы не совпадают, возвращаем false
        }
Внутри цикла мы сравниваем символы строки S и подстроки T. Если хотя бы один символ не совпадает, функция возвращает false.
Возврат результата
    }
    return true; // Если все символы совпадают, возвращаем true
}
Если все символы совпадают, функция возвращает true.
Функция findOccurrencesBruteForce
Определение функции
function findOccurrencesBruteForce(S, T) {
Эта функция ищет все вхождения подстроки T в строке S с использованием "грубого" метода.
Инициализация переменных
    const positions = []; // Массив для хранения позиций найденных вхождений
    const n = S.length; // Длина строки S
    const m = T.length; // Длина подстроки T
Создается массив positions для хранения позиций найденных вхождений. Также определяются длины строк S и T.
Цикл по возможным позициям
    for (let i = 0; i <= n - m; i++) { // Проходим по всем возможным позициям
Цикл проходит по всем возможным начальным позициям для поиска подстроки T в строке S.
Проверка на совпадение
        if (isMatch(S, T, i)) { // Проверяем совпадение подстроки
            positions.push(i + 1); // Добавляем позицию (индексация с 1)
        }
Для каждой позиции вызывается функция isMatch. Если она возвращает true, позиция добавляется в массив (с учетом индексации с 1).
Возврат результата
    }
    return positions; // Возвращаем массив позиций
}
После завершения цикла функция возвращает массив позиций.
Функция findOccurrencesWithHash
Определение функции
function findOccurrencesWithHash(S, T) {
Эта функция также ищет все вхождения подстроки T в строке S, но использует метод хеширования для оптимизации.
Инициализация переменных
    const positions = []; // Массив для хранения позиций найденных вхождений
    const n = S.length; // Длина строки S
    const m = T.length; // Длина подстроки T
Аналогично предыдущей функции, создается массив для хранения позиций и определяются длины строк.
Вычисление хеша для подстроки T и первого окна в S
    let targetHash = Array.from(T).reduce((sum, char) => sum + char.charCodeAt(0), 0);
    let currentHash = Array.from(S.slice(0, m)).reduce((sum, char) => sum + char.charCodeAt(0), 0);
Вычисляется хеш для подстроки T и первого окна длиной m в строке S, используя кодовые точки символов.
Цикл по возможным позициям с обновлением хеша
    for (let i = 0; i <= n - m; i++) { // Проходим по всем возможным позициям
        if (currentHash === targetHash && isMatch(S, T, i)) { // Сравниваем хеши и проверяем совпадение
            positions.push(i + 1); // Добавляем позицию (индексация с 1)
        }

        if (i < n - m) { // Обновляем хеш для следующего окна
            currentHash = currentHash - S.charCodeAt(i) + S.charCodeAt(i + m);
        }
    }
Цикл проходит по всем возможным позициям. Если текущий хеш совпадает с целевым хешем и функция isMatch подтверждает совпадение, позиция добавляется в массив. Затем обновляется хеш для следующего окна.
Возврат результата
    return positions; // Возвращаем массив позиций
}
В конце функция возвращает массив найденных позиций.
Пример использования
Определение примеров и вывод результатов
const examples = [
    { S: "abccacabac", T: "cab" },
    { S: "abacabababa", T: "aba" }
];

examples.forEach(({ S, T }) => {
    console.log(`Brute Force: ${findOccurrencesBruteForce(S, T)}`);
    console.log(`Hashing: ${findOccurrencesWithHash(S, T)}`);
})
Создается массив примеров с различными строками. Затем для каждого примера вызываются обе функции поиска и выводятся результаты на консоль.
Этот код демонстрирует два подхода к решению задачи поиска подстрок — один простой и понятный (грубый метод), а другой более эффективный с использованием хеширования.
