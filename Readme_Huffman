Определение класса Node
Определение класса
class Node {
    constructor(char, freq) {
        this.char = char; // Символ
        this.freq = freq; // Частота
        this.left = null; // Левый дочерний узел
        this.right = null; // Правый дочерний узел
    }
}
Объявляется класс Node, который представляет узел дерева Хаффмана.
Конструктор принимает два параметра: char (символ) и freq (частота).
Каждый узел имеет три свойства:
char: символ, который хранится в узле.
freq: частота появления этого символа.
left и right: ссылки на левые и правые дочерние узлы (инициализируются как null).
Функция для создания дерева Хаффмана
Определение функции
function buildHuffmanTree(charFreq) {
    const nodes = [];
Функция buildHuffmanTree принимает объект charFreq, который содержит частоты символов.
Создается пустой массив nodes, который будет использоваться для хранения узлов.
Создание узлов для каждого символа
    for (const [char, freq] of Object.entries(charFreq)) {
        nodes.push(new Node(char, freq));
    }
Цикл проходит по всем символам и их частотам в объекте charFreq.
Для каждого символа создается новый узел с помощью класса Node, и он добавляется в массив nodes.
Построение дерева
    while (nodes.length > 1) {
        nodes.sort((a, b) => a.freq - b.freq);
Цикл продолжается до тех пор, пока в массиве nodes больше одного узла.
Узлы сортируются по частоте в порядке возрастания.
Объединение двух узлов с наименьшей частотой
        const left = nodes.shift();
        const right = nodes.shift();
Берутся два узла с наименьшей частотой (первый и второй элементы массива) с помощью метода shift(), который удаляет первый элемент массива.
Создание нового узла
        const merged = new Node(null, left.freq + right.freq);
        merged.left = left;
        merged.right = right;
Создается новый узел merged, который не содержит символа (char равен null), но его частота равна сумме частот двух извлеченных узлов.
Левый и правый дочерние узлы нового узла устанавливаются на извлеченные узлы.
Добавление нового узла обратно в массив
        nodes.push(merged);
    }
Новый объединенный узел добавляется обратно в массив nodes.
Возврат корня дерева
    return nodes[0]; // Корень дерева
}
Когда в массиве остается только один узел, он становится корнем дерева Хаффмана и возвращается.
Функция для генерации кодов Хаффмана
Определение функции
function generateHuffmanCodes(node, prefix = '', codes = {}) {
Функция generateHuffmanCodes принимает текущий узел (node), префикс кода (prefix) и объект для хранения кодов (codes).
Проверка наличия узла
    if (node) {
Проверяется, существует ли текущий узел.
Сохранение кода для символа
        if (node.char !== null) {
            codes[node.char] = prefix; // Сохраняем код для символа
        }
Если текущий узел содержит символ (т.е. не является внутренним узлом), сохраняется код для этого символа в объекте codes.
Рекурсивный вызов для дочерних узлов
        generateHuffmanCodes(node.left, prefix + '0', codes); // Левый дочерний узел
        generateHuffmanCodes(node.right, prefix + '1', codes); // Правый дочерний узел
    }
    return codes;
}
Рекурсивно вызывается функция для левого дочернего узла с добавлением '0' к префиксу.
Рекурсивно вызывается функция для правого дочернего узла с добавлением '1' к префиксу.
Возвращается объект с кодами.
Основная функция для кодирования строки
Определение функции кодирования
function huffmanEncode(input) {
Функция huffmanEncode принимает входную строку (input) и выполняет процесс кодирования.
Подсчет частоты символов
    const charFreq = {};
    for (const char of input) {
        charFreq[char] = (charFreq[char] || 0) + 1;
    }
Создается объект charFreq, который будет хранить частоты каждого символа.
Цикл проходит по каждому символу строки и увеличивает его частоту в объекте.
Строим дерево Хаффмана
    const huffmanTree = buildHuffmanTree(charFreq);
Вызывается функция buildHuffmanTree, чтобы построить дерево Хаффмана на основе частот символов.
Генерация кодов Хаффмана
    const huffmanCodes = generateHuffmanCodes(huffmanTree);
Вызывается функция generateHuffmanCodes, чтобы получить коды Хаффмана для каждого символа.
Кодирование строки
    let encodedString = '';
    for (const char of input) {
        encodedString += huffmanCodes[char];
    }
Создается пустая строка encodedString.
Цикл проходит по каждому символу входной строки и добавляет соответствующий ему код из объекта huffmanCodes.
Возврат результата кодирования
    return { encodedString, huffmanCodes };
}
Возвращается объект, содержащий закодированную строку и коды Хаффмана.
Пример использования
Входные данные и вызов функции кодирования
const inputString = "hello huffman";
const { encodedString, huffmanCodes } = huffmanEncode(inputString);
Входная строка "hello huffman" передается в функцию huffmanEncode.
Результат распаковывается в переменные encodedString и huffmanCodes.
Вывод результата в консоль
console.log("Encoded String:", encodedString);
console.log("Huffman Codes:", huffmanCodes);
Закодированная строка и коды Хаффмана выводятся в консоль.
Заключение
Код реализует алгоритм Хаффмана для сжатия данных. Он включает следующие этапы:
Подсчет частоты появления каждого символа в строке.
Построение дерева Хаффмана на основе этих частот.
Генерация уникальных двоичных кодов для каждого символа.
Кодирование исходной строки с использованием полученных кодов.
Этот алгоритм позволяет эффективно сжимать данные за счет использования более коротких кодов для часто встречающихся символов.
