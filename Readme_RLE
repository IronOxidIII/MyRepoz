Код реализует алгоритм сжатия данных методом "упаковки повторяющихся символов" (Run-Length Encoding, RLE) и его декодирования.

  Функция rleEncode
Определение функции
function rleEncode(input) {
Объявляется функция rleEncode, которая принимает строку input в качестве аргумента.
Инициализация переменных
    let encoded = '';
    let count = 1;
encoded — строка для хранения закодированного результата.
count — счетчик, который отслеживает количество повторений текущего символа, инициализируется значением 1.
Цикл по символам строки
    for (let i = 0; i < input.length; i++) {
Начинается цикл, который проходит по каждому символу входной строки.
Проверка повторяющихся символов
        if (input[i] === input[i + 1]) {
            count++;
        } else {
Если текущий символ равен следующему (input[i + 1]), увеличиваем счетчик count.
Если символы не равны (или это последний символ), выполняется блок кода в else.
Добавление символов и их количества в закодированную строку
            encoded += input[i];
            if (count > 1) {
                encoded += count;
            }
            count = 1;
Добавляем текущий символ в строку encoded.
Если count больше 1, добавляем значение count к строке.
Сбрасываем счетчик count на 1 для следующего символа.
Возврат закодированной строки
    }
    return encoded;
}
После завершения цикла возвращаем закодированную строку.

  Функция rleDecode
Определение функции
function rleDecode(encoded) {
Объявляется функция rleDecode, которая принимает закодированную строку encoded.
Инициализация переменных
    let decoded = '';
    let i = 0;
decoded — строка для хранения декодированного результата.
i — индекс для перебора символов закодированной строки.
Цикл по закодированной строке
    while (i < encoded.length) {
Начинается цикл, который продолжается до тех пор, пока не достигнут конец закодированной строки.
Получение текущего символа
        const char = encoded[i];
        i++;
Сохраняем текущий символ в переменной char и увеличиваем индекс i.
Чтение числа (количества повторений)
        let count = '';
        while (i < encoded.length && !isNaN(encoded[i])) {
            count += encoded[i];
            i++;
        }
Инициализируем пустую строку count.
Внутренний цикл считывает все цифры после текущего символа и добавляет их к строке count, пока не встретит нечисловой символ.
Формирование декодированной строки
        decoded += char.repeat(count ? parseInt(count) : 1);
Добавляем в строку decoded текущий символ, повторенный количество раз, указанное в count. Если count пустой, повторяем один раз.
Возврат декодированной строки
    }
    return decoded;
}
После завершения цикла возвращаем декодированную строку.

  Пример использования:
Кодирование строки
const inputString = "aaaabbcccdee";
const encodedString = rleEncode(inputString);
console.log(encodedString);
Строка "aaaabbcccdee" кодируется с помощью функции rleEncode, результат выводится в консоль.
Декодирование строки
const encodedString1 = "a5gr2";
const decodedString = rleDecode(encodedString1);
console.log(decodedString);
Закодированная строка "a5gr2" декодируется с помощью функции rleDecode, результат также выводится в консоль.
Таким образом, код реализует эффективное сжатие и восстановление данных с использованием метода RLE.
