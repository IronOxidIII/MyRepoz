Код
let fs = require('fs');
let arg = process.argv;
Импорт модуля fs: Этот модуль позволяет работать с файловой системой, например, читать файлы.
Получение аргументов командной строки: process.argv — это массив, содержащий аргументы, переданные при запуске скрипта.
Первый элемент — это путь к Node.js, второй — путь к скрипту, а последующие — подстрока.
Проверка наличия аргументов
try {
    // Чтение текста из файла
    let inText = fs.readFileSync(arg[2], 'utf-8');
    let subString = arg[3]; // Подстрока передается как третий аргумент
Чтение текста из файла: Содержимое файла считывается в переменную inText с использованием кодировки UTF-8.
Инициализация подстроки: subString получает значение искомой подстроки из аргументов командной строки.
Инициализация переменных
    let m = subString.length;
    let n = inText.length;
Длина подстроки и текста: m — длина искомой подстроки, n — длина текста.
Эти значения понадобятся для формирования таблицы переходов и для цикла поиска.
Определение алфавита
    let alph = {};
    for (let i = 0; i < m; i++) {
        alph[subString.charAt(i)] = 0;
    }
Определение алфавита: Создается объект alph, который будет хранить уникальные символы из подстроки.
Каждый символ инициализируется значением 0. Это необходимо для построения таблицы переходов.
Таблица переходов
    let del = new Array(m + 1);
    for (let j = 0; j <= m; j++) {
        del[j] = {};
    }
Создание таблицы переходов: Двумерный массив del, где строки представляют состояния автомата (от 0 до m),
а столбцы — символы алфавита. Каждое состояние будет хранить переходы для каждого символа.
Инициализация таблицы переходов
    for (let i in alph) {
        del[0][i] = 0;
    }
Инициализация начального состояния: Все переходы из начального состояния (состояние 0) ведут обратно в состояние 0 для всех символов,
которые не соответствуют первому символу подстроки.
Формирование таблицы переходов
    for (let j = 0; j < m; j++) {
        let prev = del[j][subString.charAt(j)];
        del[j][subString.charAt(j)] = j + 1;
        for (let i in alph) {
            del[j + 1][i] = del[prev][i];
        }
    }
Заполнение таблицы переходов:
Внешний цикл проходит по каждому символу подстроки.
Для текущего состояния j, если символ соответствует текущему символу подстроки, происходит переход на следующее состояние (j + 1).
Внутренний цикл обновляет переходы для всех остальных символов на основе предыдущих состояний.
Это позволяет автомату "запоминать", где он находился до этого.
Вывод таблицы переходов
    console.log("Таблица переходов:");
    for (let j = 0; j <= m; j++) {
        let out = `Состояние ${j}: `;
        for (let i in alph) {
            out += `${i}: ${del[j][i] || 0} `;
        }
        console.log(out);
    }
Вывод таблицы: Печатается таблица переходов для визуализации работы автомата.
Каждая строка показывает текущее состояние и соответствующие ему переходы для каждого символа алфавита.
Поиск подстроки в тексте
    let results = [];
    let state = 0;

    for (let i = 0; i < n; i++) {
        if (inText.charAt(i) in alph) {
            state = del[state][inText.charAt(i)];
        } else {
            state = 0;
        }
        if (state == m) {
            results.push(i - m + 1); // Сохраняем индекс начала вхождения
        }
    }
Инициализация результатов и состояния: Создается массив для хранения индексов найденных вхождений и начальное состояние автомата.
Поиск по тексту:
Для каждого символа текста проверяется, есть ли он в алфавите.
Если символ есть, происходит переход по таблице. Если символа нет, состояние сбрасывается на 0.
Если достигнуто состояние m, это означает, что найдена полная подстрока, и индекс начала вхождения добавляется в результаты.
Вывод результатов
    console.log("Индексы вхождений подстроки:", results);
} catch (err) {
    console.error(err);
}
Вывод найденных позиций: Печатаются индексы всех найденных вхождений искомой подстроки.
Обработка ошибок: Если возникает ошибка при чтении файла или выполнении кода, она обрабатывается и выводится сообщение об ошибке.
Алгоритм детерминированного конечного автомата
Алгоритм ДКА работает следующим образом:
Состояния: Каждое состояние соответствует количеству совпавших символов из подстроки.
Начальное состояние — это состояние, когда не найдено ни одного совпадения.
Переходы: Таблица переходов определяет, как изменяется состояние автомата при получении нового символа из текста.
Если текущий символ совпадает с ожидаемым, автомат переходит к следующему состоянию. Если нет — сбрасывается на начальное состояние.
Поиск совпадений: Проходя по тексту, автомат обновляет свое состояние на основе текущего символа и таблицы переходов.
Когда автомат достигает состояния, равного длине искомой подстроки (m), это означает, что найдено полное совпадение, и индекс начала этого совпадения сохраняется.
Таким образом, данный код реализует эффективный алгоритм поиска подстроки с использованием детерминированного конечного автомата, что позволяет находить все вхождения искомой подстроки за линейное время относительно длины текста.
